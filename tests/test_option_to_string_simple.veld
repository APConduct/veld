# Test basic Option to_string functionality
# This test uses simple cases that work with current type inference

fn main()
    std.io.println("=== Testing Option<T> to_string (Simple) ===")

    # Test 1: Option<i32> from Some(42) - should work
    std.io.println("\n--- Test 1: Option<i32> from Some(42) ---")
    let int_option = std.option.Option.Some(42)
    let int_str = int_option.to_string()
    std.io.println("Option.Some(42).to_string(): " + int_str)

    # Test 2: Option<str> from Some("hello") - should work
    std.io.println("\n--- Test 2: Option<str> from Some(\"hello\") ---")
    let str_option = std.option.Option.Some("hello")
    let str_str = str_option.to_string()
    std.io.println("Option.Some(\"hello\").to_string(): " + str_str)

    # Test 3: Option<bool> from Some(true) - should work
    std.io.println("\n--- Test 3: Option<bool> from Some(true) ---")
    let bool_option = std.option.Option.Some(true)
    let bool_str = bool_option.to_string()
    std.io.println("Option.Some(true).to_string(): " + bool_str)

    # Test 4: Direct None access - this might have type inference issues but let's try
    std.io.println("\n--- Test 4: Trying Option.None directly ---")
    # This might fail due to type inference, but let's see what happens

    std.io.println("\nâœ… Basic Option to_string tests completed!")
end

main()
