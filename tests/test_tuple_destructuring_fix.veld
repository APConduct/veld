# Test: Tuple Destructuring Fix - All Contexts

std.io.println("=== Tuple Destructuring Fix Tests ===\n")

# ============================================================================
# TEST 1: Filter with Tuple Destructuring
# ============================================================================
std.io.println("Test 1: Filter with tuple destructuring")
let indexed = ["a", "b", "c", "d", "e"].enumerate()

let result = indexed.filter((pair) => do
    let (i, val) = pair
    i % 2 == 0
end)

std.io.println("  Filtered even indices count: " + result.len().to_str())
std.io.println("  Expected: 3")

# ============================================================================
# TEST 2: For Loop with Enumerate
# ============================================================================
std.io.println("\nTest 2: For loop with enumerate")
let fruits = ["apple", "banana", "cherry"]
let indexed_fruits = fruits.enumerate()

std.io.println("  Iterating with for loop:")
for (i, fruit) in indexed_fruits do
    std.io.println("    [" + i.to_str() + "] " + fruit)
end

# ============================================================================
# TEST 3: Filter with Zip Result
# ============================================================================
std.io.println("\nTest 3: Filter with zip result")
let names = ["Alice", "Bob", "Charlie", "Dave"]
let ages = [25, 17, 30, 16]
let people = names.zip(ages)

let adults = people.filter((person) => do
    let (name, age) = person
    age >= 18
end)

std.io.println("  Adults count: " + adults.len().to_str())
std.io.println("  Expected: 2 (Alice 25, Charlie 30)")

# ============================================================================
# TEST 4: For Loop with Zip
# ============================================================================
std.io.println("\nTest 4: For loop with zip")
let cities = ["NYC", "LA", "Chicago"]
let populations = [8000000, 4000000, 3000000]
let city_data = cities.zip(populations)

std.io.println("  City populations:")
for (city, pop) in city_data do
    std.io.println("    " + city + ": " + pop.to_str())
end

# ============================================================================
# TEST 5: Nested Tuple Destructuring in Filter
# ============================================================================
std.io.println("\nTest 5: Nested tuple destructuring")
let data = [(1, (2, 3)), (4, (5, 6)), (7, (8, 9))]

let filtered_nested = data.filter((item) => do
    let (a, (b, c)) = item
    a + b + c > 10
end)

std.io.println("  Filtered nested tuples: " + filtered_nested.len().to_str())
std.io.println("  Expected: 2")

# ============================================================================
# TEST 6: Any with Tuple Destructuring
# ============================================================================
std.io.println("\nTest 6: Any with tuple destructuring")
let scores = [("Alice", 85), ("Bob", 72), ("Charlie", 91)]

let has_high_score = scores.any((entry) => do
    let (name, score) = entry
    score > 90
end)

std.io.println("  Has score > 90: " + has_high_score.to_str())
std.io.println("  Expected: true")

# ============================================================================
# TEST 7: All with Tuple Destructuring
# ============================================================================
std.io.println("\nTest 7: All with tuple destructuring")
let all_passing = scores.all((entry) => do
    let (name, score) = entry
    score >= 60
end)

std.io.println("  All passing: " + all_passing.to_str())
std.io.println("  Expected: true")

# ============================================================================
# TEST 8: Find with Tuple Destructuring
# ============================================================================
std.io.println("\nTest 8: Find with tuple destructuring")
let found = scores.find((entry) => do
    let (name, score) = entry
    name == "Bob"
end)

match found
    Option.Some(entry) => do
        let (n, s) = entry
        std.io.println("  Found: " + n + " with score " + s.to_str())
    end
    Option.None => std.io.println("  Not found")
end

# ============================================================================
# TEST 9: Partition with Tuple Destructuring
# ============================================================================
std.io.println("\nTest 9: Partition with tuple destructuring")
let items = [(1, 10), (2, 20), (3, 30), (4, 40)]

let (small, large) = items.partition((item) => do
    let (id, value) = item
    value < 30
end)

std.io.println("  Small items: " + small.len().to_str())
std.io.println("  Large items: " + large.len().to_str())
std.io.println("  Expected: 2 small, 2 large")

# ============================================================================
# TEST 10: Take While with Tuple Destructuring
# ============================================================================
std.io.println("\nTest 10: Take while with tuple destructuring")
let sequence = [(1, 5), (2, 10), (3, 15), (4, 20), (5, 25)]

let taken = sequence.take_while((item) => do
    let (idx, val) = item
    val < 20
end)

std.io.println("  Taken count: " + taken.len().to_str())
std.io.println("  Expected: 3")

# ============================================================================
# TEST 11: Drop While with Tuple Destructuring
# ============================================================================
std.io.println("\nTest 11: Drop while with tuple destructuring")
let dropped = sequence.drop_while((item) => do
    let (idx, val) = item
    val < 20
end)

std.io.println("  Remaining count: " + dropped.len().to_str())
std.io.println("  Expected: 2")

# ============================================================================
# TEST 12: Complex Pipeline with Tuple Destructuring
# ============================================================================
std.io.println("\nTest 12: Complex pipeline")
let raw = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

let result12 = raw
    .enumerate()
    .filter((pair) => do
        let (i, n) = pair
        n % 2 == 0
    end)
    .map((pair) => do
        let (i, n) = pair
        (i, n * 2)
    end)

std.io.println("  Pipeline result length: " + result12.len().to_str())
std.io.println("  Expected: 5")

# ============================================================================
# TEST 13: Reduce with Enumerated Data
# ============================================================================
std.io.println("\nTest 13: Reduce with enumerated data")
let nums = [10, 20, 30, 40]
let enum_nums = nums.enumerate()

let sum_with_indices = enum_nums.reduce(0, (acc, pair) => do
    let (idx, val) = pair
    acc + val + idx
end)

std.io.println("  Sum (values + indices): " + sum_with_indices.to_str())
std.io.println("  Expected: 106 ((10+0) + (20+1) + (30+2) + (40+3))")

# ============================================================================
# TEST 14: Let Binding with Complex Tuple
# ============================================================================
std.io.println("\nTest 14: Let binding with complex tuple")
let complex_data = [(1, 2), (3, 4), (5, 6)]
# Access directly and destructure
let result14 = complex_data.map((pair) => do
    let (a, b) = pair
    (a, b)
end)
std.io.println("  Destructuring works in map: " + result14.len().to_str() + " pairs processed")
std.io.println("  Expected: 3 pairs processed")

# ============================================================================
# TEST 15: For Loop with Partition Result
# ============================================================================
std.io.println("\nTest 15: For loop with partition result")
let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let (evens, odds) = values.partition(x => x % 2 == 0)

std.io.println("  Even numbers:")
for num in evens do
    std.io.print("    " + num.to_str() + " ")
end
std.io.println("")

std.io.println("  Odd numbers:")
for num in odds do
    std.io.print("    " + num.to_str() + " ")
end
std.io.println("")

# ============================================================================
# TEST 16: Multiple Tuple Destructuring Levels
# ============================================================================
std.io.println("\nTest 16: Multiple destructuring levels")
let nested = [((1, 2), 3), ((4, 5), 6), ((7, 8), 9)]

let processed = nested.map((item) => do
    let ((x, y), z) = item
    x + y + z
end)

std.io.println("  Processed sums length: " + processed.len().to_str())
std.io.println("  Expected: 3")

# ============================================================================
# TEST 17: Filter Then For Loop
# ============================================================================
std.io.println("\nTest 17: Filter then for loop")
let pairs = [(1, 10), (2, 20), (3, 30), (4, 40)]
let large_pairs = pairs.filter((p) => do
    let (id, val) = p
    val >= 30
end)

std.io.println("  Large pairs:")
for (identifier, value) in large_pairs do
    std.io.println("    ID " + identifier.to_str() + " = " + value.to_str())
end

# ============================================================================
# TEST 18: Wildcard in Tuple Pattern
# ============================================================================
std.io.println("\nTest 18: Wildcard in tuple pattern")
let data18 = [(1, 100), (2, 200), (3, 300)]

let ids = data18.map((item) => do
    let (id, _) = item
    id
end)

std.io.println("  Extracted IDs count: " + ids.len().to_str())
std.io.println("  Expected: 3")

# ============================================================================
# TEST 19: Zip Two Enumerated Arrays
# ============================================================================
std.io.println("\nTest 19: Zip enumerated arrays")
let arr1 = [10, 20, 30].enumerate()
let arr2 = [100, 200, 300].enumerate()
let zipped = arr1.zip(arr2)

std.io.println("  Zipped enumerated count: " + zipped.len().to_str())
std.io.println("  Expected: 3")

# ============================================================================
# TEST 20: Ultimate Combo Test
# ============================================================================
std.io.println("\nTest 20: Ultimate combo - all features")
let ultimate = [5, 10, 15, 20, 25, 30, 35, 40]

let ultimate_result = ultimate
    .enumerate()                      # Add indices
    .filter((pair) => do              # Filter by tuple destructuring
        let (i, n) = pair
        n > 10 and i % 2 == 0
    end)
    .map((pair) => do                 # Transform with destructuring
        let (i, n) = pair
        (i, n * 2)
    end)

std.io.println("  Ultimate result length: " + ultimate_result.len().to_str())
std.io.println("  Expected: 2 or 3")

# ============================================================================
# Summary
# ============================================================================
std.io.println("\n=== Summary ===")
std.io.println("âœ… All tuple destructuring contexts tested:")
std.io.println("  â€¢ Filter with tuple destructuring")
std.io.println("  â€¢ For loops with tuples")
std.io.println("  â€¢ Enumerate in all contexts")
std.io.println("  â€¢ Zip with destructuring")
std.io.println("  â€¢ Nested tuple patterns")
std.io.println("  â€¢ Any/All/Find with tuples")
std.io.println("  â€¢ Partition with tuples")
std.io.println("  â€¢ Take/Drop while with tuples")
std.io.println("  â€¢ Complex pipelines")
std.io.println("  â€¢ Reduce with tuples")
std.io.println("\nðŸŽ‰ All tuple destructuring bugs FIXED!")
