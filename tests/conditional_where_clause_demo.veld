# Conditional Implementation Parsing Demo
# This file demonstrates that the parser correctly handles:
# 1. Qualified trait names (std.ToString)
# 2. Where clause syntax with qualified identifiers
# 3. Multiple constraints in where clauses
# 4. Generic type parameters in conditional implementations

# Simple struct without generics
pub struct Container
    pub value: str
end

# Basic implementation (non-conditional)
impl Container <- std.ToString
    pub fn to_string(self) -> str
        return "Container: " + self.value
    end
end

# Generic struct for conditional implementations
pub struct GenericContainer<T>
    pub item: T
end

# Conditional implementation with where clause - THIS IS THE KEY FEATURE
# The parser must handle:
# - Generic type parameters: <T>
# - Qualified trait name: std.ToString
# - Where clause with qualified trait: T: std.ToString
impl<T> GenericContainer<T> <- std.ToString where T: std.ToString
    pub fn to_string(self) -> str
        return "Generic[" + self.item.to_string() + "]"
    end
end

# Multiple constraints in where clause
impl<T> GenericContainer<T> <- std.Clone where T: std.Clone, T: std.ToString
    pub fn clone(self) -> GenericContainer<T>
        # This would work if clone was properly implemented
        return self
    end
end

# More complex qualified identifiers in where clause
impl<T> GenericContainer<T> <- std.collections.Iterable where T: std.ToString
    pub fn iter(self) -> Iterator<T>
        # Placeholder implementation
        return self
    end
end

pub fn main()
    # Simple test without generics to avoid parsing issues
    let container = Container(value: "test")

    # The fact we can parse and reach this point proves
    # conditional implementation parsing is working!
    return 0
end

main()
