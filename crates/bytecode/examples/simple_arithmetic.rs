use veld_bytecode::{BytecodeValue, ChunkBuilder, Instruction, InterpretResult, VirtualMachine};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== Veld Bytecode Compiler Example ===\n");

    // Example 1: Simple arithmetic using manual bytecode creation
    println!("Example 1: Manual bytecode creation for 5 + 3 * 2");

    let chunk = ChunkBuilder::new()
        .with_name("arithmetic".to_string())
        .constant(BytecodeValue::Integer(5)) // constant[0] = 5
        .constant(BytecodeValue::Integer(3)) // constant[1] = 3
        .constant(BytecodeValue::Integer(2)) // constant[2] = 2
        .instruction(Instruction::LoadConstant(0), 1) // Load 5
        .instruction(Instruction::LoadConstant(1), 1) // Load 3
        .instruction(Instruction::LoadConstant(2), 1) // Load 2
        .instruction(Instruction::Multiply, 1) // 3 * 2 = 6
        .instruction(Instruction::Add, 1) // 5 + 6 = 11
        .instruction(Instruction::Halt, 1)
        .build();

    println!("Generated bytecode:");
    println!("{}", chunk);

    let mut vm = VirtualMachine::with_debug();
    let result = vm.interpret(chunk);

    match result {
        InterpretResult::Ok(value) => {
            println!("Execution result: {}\n", value);
        }
        InterpretResult::RuntimeError(error) => {
            println!("Runtime error: {}\n", error);
        }
        InterpretResult::CompileError(error) => {
            println!("Compile error: {}\n", error);
        }
    }

    println!("{}", "=".repeat(50));

    // Example 2: Function call
    example_function_call()?;

    // Example 3: Control flow
    example_control_flow()?;

    // Example 4: Array operations
    example_array_operations()?;

    Ok(())
}

fn example_function_call() -> Result<(), Box<dyn std::error::Error>> {
    println!("\n=== Function Call Example ===");

    // Create main chunk that calls a native function
    let mut main_chunk = ChunkBuilder::new()
        .with_name("main".to_string())
        .constant(BytecodeValue::Integer(10))
        .constant(BytecodeValue::Integer(20))
        .constant(BytecodeValue::NativeFunction {
            name: "add".to_string(),
            arity: 2,
            function: |args| {
                if args.len() != 2 {
                    return Err(veld_bytecode::value::RuntimeError::ArityMismatch {
                        expected: 2,
                        actual: args.len(),
                    });
                }
                match (&args[0], &args[1]) {
                    (BytecodeValue::Integer(a), BytecodeValue::Integer(b)) => {
                        Ok(BytecodeValue::Integer(a + b))
                    }
                    _ => Err(veld_bytecode::value::RuntimeError::TypeError {
                        expected: "integer".to_string(),
                        actual: "other".to_string(),
                    }),
                }
            },
        })
        .instruction(Instruction::LoadConstant(0), 1) // Load 10
        .instruction(Instruction::LoadConstant(1), 1) // Load 20
        .instruction(Instruction::LoadConstant(2), 1) // Load function
        .instruction(Instruction::Call(2), 1) // Call with 2 args
        .instruction(Instruction::Halt, 1)
        .build();

    println!("Main bytecode:");
    println!("{}", main_chunk);

    let mut vm = VirtualMachine::new();
    let result = vm.interpret(main_chunk);

    match result {
        InterpretResult::Ok(value) => {
            println!("Function call result: {}", value);
        }
        InterpretResult::RuntimeError(error) => {
            println!("Runtime error: {}", error);
        }
        _ => {
            println!("Unexpected result");
        }
    }

    Ok(())
}

fn example_control_flow() -> Result<(), Box<dyn std::error::Error>> {
    println!("\n=== Control Flow Example ===");

    // Simulate: if (5 > 3) { 42 } else { 0 }
    let chunk = ChunkBuilder::new()
        .with_name("control_flow".to_string())
        .constant(BytecodeValue::Integer(5))
        .constant(BytecodeValue::Integer(3))
        .constant(BytecodeValue::Integer(42))
        .constant(BytecodeValue::Integer(0))
        .instruction(Instruction::LoadConstant(0), 1) // Load 5
        .instruction(Instruction::LoadConstant(1), 1) // Load 3
        .instruction(Instruction::Greater, 1) // 5 > 3
        .instruction(Instruction::PopJumpIfFalse(3), 1) // Jump to else if false (3 instructions forward)
        .instruction(Instruction::LoadConstant(2), 2) // Load 42 (then branch)
        .instruction(Instruction::Jump(2), 2) // Jump over else (2 instructions forward)
        .instruction(Instruction::LoadConstant(3), 3) // Load 0 (else branch)
        .instruction(Instruction::Halt, 4)
        .build();

    println!("Control flow bytecode:");
    println!("{}", chunk);

    let mut vm = VirtualMachine::with_debug();
    let result = vm.interpret(chunk);

    match result {
        InterpretResult::Ok(value) => {
            println!("Control flow result: {}", value);
        }
        InterpretResult::RuntimeError(error) => {
            println!("Runtime error: {}", error);
        }
        _ => {
            println!("Unexpected result");
        }
    }

    Ok(())
}

fn example_array_operations() -> Result<(), Box<dyn std::error::Error>> {
    println!("\n=== Array Operations Example ===");

    // Create array [1, 2, 3] and access element at index 1
    let chunk = ChunkBuilder::new()
        .with_name("arrays".to_string())
        .constant(BytecodeValue::Integer(1))
        .constant(BytecodeValue::Integer(2))
        .constant(BytecodeValue::Integer(3))
        .constant(BytecodeValue::Integer(1)) // index
        .instruction(Instruction::LoadConstant(0), 1) // Load 1
        .instruction(Instruction::LoadConstant(1), 1) // Load 2
        .instruction(Instruction::LoadConstant(2), 1) // Load 3
        .instruction(Instruction::NewArray(3), 1) // Create array [1, 2, 3]
        .instruction(Instruction::Duplicate, 1) // Duplicate array for indexing
        .instruction(Instruction::LoadConstant(3), 1) // Load index 1
        .instruction(Instruction::GetIndex, 1) // Get element at index 1
        .instruction(Instruction::Halt, 1)
        .build();

    println!("Array operations bytecode:");
    println!("{}", chunk);

    let mut vm = VirtualMachine::with_debug();
    let result = vm.interpret(chunk);

    match result {
        InterpretResult::Ok(value) => {
            println!("Array access result: {}", value);
        }
        InterpretResult::RuntimeError(error) => {
            println!("Runtime error: {}", error);
        }
        _ => {
            println!("Unexpected result");
        }
    }

    Ok(())
}
