# Debug nested generic type parameter substitution issue

fn main()
    std.io.println("=== Debugging Nested Generic Substitution ===")

    # Test 1: Simple Vec<i32> - should work
    std.io.println("\n--- Test 1: Vec<i32> (working case) ---")
    var vec_int: Vec<i32> = std.vec.Vec.new()
    vec_int.push(42)
    std.io.println("Vec<i32>.push(42) works")

    # Test 2: Create Option<i32> separately first
    std.io.println("\n--- Test 2: Create Option<i32> separately ---")
    let opt_int: Option<i32> = std.option.Option.Some(100)
    std.io.println("Option<i32> created: Some(100)")

    # Test 3: Vec<Option<i32>> creation only
    std.io.println("\n--- Test 3: Vec<Option<i32>> creation ---")
    var vec_opt: Vec<Option<i32>> = std.vec.Vec.new()
    std.io.println("Vec<Option<i32>> created successfully")

    # Test 4: Push the pre-created Option to Vec<Option<i32>>
    std.io.println("\n--- Test 4: Push pre-created Option ---")
    vec_opt.push(opt_int)
    std.io.println("vec_opt.push(pre_created_option) works")

    # Test 5: The problematic case - direct Option creation in push
    std.io.println("\n--- Test 5: Direct Option.Some() in push (fails here) ---")
    vec_opt.push(std.option.Option.Some(200))
    std.io.println("vec_opt.push(Option.Some(200)) works")

    std.io.println("\nâœ… All nested substitution tests passed!")
end

main()
