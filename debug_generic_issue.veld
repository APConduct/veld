# Minimal test to isolate the generic type parameter resolution issue

fn main()
    std.io.println("=== Debugging Generic Type Parameter Resolution ===")

    # Test 1: Create Vec without type annotation
    std.io.println("\n--- Test 1: Creating Vec without annotation ---")
    var vec_no_annotation = std.vec.Vec.new()
    std.io.println("Vec created without annotation")

    # Test 2: Push to Vec without annotation (infer types)
    std.io.println("\n--- Test 2: Push to untyped Vec ---")
    vec_no_annotation.push(42)
    std.io.println("Pushed 42 to untyped Vec")

    # Test 3: Create another Vec and push Option
    std.io.println("\n--- Test 3: Push Option to untyped Vec ---")
    var vec_option = std.vec.Vec.new()
    vec_option.push(std.option.Option.Some(100))
    std.io.println("Pushed Option.Some(100) to untyped Vec")

    # Test 4: Try to push another Option to the same Vec
    std.io.println("\n--- Test 4: Push second Option ---")
    vec_option.push(std.option.Option.None)
    std.io.println("Pushed Option.None to the same Vec")

    # Test 5: This is where the issue likely occurs - when we have an explicit type annotation
    std.io.println("\n--- Test 5: Explicit Vec<Option<i32>> annotation ---")
    var typed_vec: Vec<Option<i32>> = std.vec.Vec.new()
    std.io.println("Created Vec<Option<i32>> with explicit type")

    # Test 6: Push to explicitly typed Vec - this should trigger the bug
    std.io.println("\n--- Test 6: Push to explicitly typed Vec (bug trigger) ---")
    typed_vec.push(std.option.Option.Some(200))
    std.io.println("Pushed to explicitly typed Vec")

    std.io.println("\nâœ… All tests passed!")
end

main()
