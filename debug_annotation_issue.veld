# Test with and without type annotations to isolate the unification issue

fn main()
    std.io.println("=== Testing Type Annotations vs No Annotations ===")

    # Test 1: Vec<i32> without annotation (should work)
    std.io.println("\n--- Test 1: Vec<i32> no annotation ---")
    var vec1 = std.vec.Vec.new()
    vec1.push(42)
    std.io.println("Vec without annotation works")

    # Test 2: Vec<i32> with annotation (should work)
    std.io.println("\n--- Test 2: Vec<i32> with annotation ---")
    var vec2: Vec<i32> = std.vec.Vec.new()
    vec2.push(43)
    std.io.println("Vec<i32> with annotation works")

    # Test 3: Vec<Option<i32>> without annotation (should work)
    std.io.println("\n--- Test 3: Vec<Option<i32>> no annotation ---")
    var vec3 = std.vec.Vec.new()
    vec3.push(std.option.Option.Some(44))
    vec3.push(std.option.Option.None)
    std.io.println("Vec without annotation for Option works")

    # Test 4: Vec<Option<i32>> with annotation (this might fail!)
    std.io.println("\n--- Test 4: Vec<Option<i32>> with annotation (problematic?) ---")
    var vec4: Vec<Option<i32>> = std.vec.Vec.new()
    vec4.push(std.option.Option.Some(45))
    std.io.println("Vec<Option<i32>> with annotation works")

    std.io.println("\nâœ… All annotation tests passed!")
end

main()
