#| Test for generic plex types without Option enum

# Test basic generic plex declaration
plex Container<T> = { value: T, count: i32 }

# Test using generic plex with specific types
let int_container: Container<i32> = { value: 42, count: 1 }
let str_container: Container<str> = { value: "hello", count: 5 }

# Test accessing fields from generic plex
let int_value = int_container.value
let int_count = int_container.count
let str_value = str_container.value
let str_count = str_container.count

# Test generic plex with multiple type parameters
plex Pair<T, U> = { first: T, second: U }

let mixed_pair: Pair<i32, str> = { first: 100, second: "world" }
let first_val = mixed_pair.first
let second_val = mixed_pair.second

# Test without generic functions (generic functions not yet fully supported)
# Just test direct access and manipulation
let extracted = int_container.value

# Test creating containers manually
let new_container: Container<i32> = { value: 99, count: 1 }
let new_value = new_container.value

# Test nested generic plex types with simple types
plex SimpleResult<T, E> = { ok: T, err: E, valid: bool }

let success_result: SimpleResult<i32, str> = {
    ok: 42,
    err: "none",
    valid: true
}

let ok_value = success_result.ok
let is_valid = success_result.valid
