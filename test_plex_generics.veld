#| Test for generic plex types

# Test basic generic plex declaration
plex Container<T> = { value: T, count: i32 }

# Test using generic plex with specific types
let int_container: Container<i32> = { value: 42, count: 1 }
let str_container: Container<str> = { value: "hello", count: 5 }

# Test accessing fields from generic plex
let int_value = int_container.value
let int_count = int_container.count
let str_value = str_container.value
let str_count = str_container.count

# Test generic plex with multiple type parameters
plex Pair<T, U> = { first: T, second: U }

let mixed_pair: Pair<i32, str> = { first: 100, second: "world" }
let first_val = mixed_pair.first
let second_val = mixed_pair.second

# Test nested generic plex types
plex Result<T, E> = { ok: Option<T>, err: Option<E> }

let success_result: Result<i32, str> = {
    ok: Option.Some(42),
    err: Option.None
}

# Test function with generic plex parameters
fn extract_value<T>(container: Container<T>) -> T
    container.value
end

let extracted = extract_value(int_container)

# Test function returning generic plex type
fn make_container<T>(val: T) -> Container<T>
    { value: val, count: 1 }
end

let new_container = make_container(99)
let new_value = new_container.value
