pub enum Option<T>
    Some(T),
    None,
end

impl<T> Option<T>
    pub fn unwrap_or(self, default: T) -> T
        match self
            Option.Some(value) => value,
            Option.None => default,
        end
    end

    pub fn unwrap(self) -> T
        match self
            Option.Some(value) => value,
            Option.None => panic~("Called unwrap() on None"),
        end
    end

    pub fn map<U>(self, f: (T) -> U) -> Option<U>
        match self
            Option.Some(value) => Option.Some(f(value)),
            Option.None => Option.None,
        end
    end

    pub fn is_some(self) -> bool
        match self
            Option.Some(_) => true,
            Option.None => false,
        end
    end

    pub fn is_none(self) -> bool
        match self
            Option.Some(_) => false,
            Option.None => true,
        end
    end

    pub fn and_then<U>(self, f: (T) -> Option<U>) -> Option<U>
        match self
            Option.Some(value) => f(value),
            Option.None => Option.None,
        end
    end

    pub fn or_else(self, f: () -> Option<T>) -> Option<T>
        match self
            Option.Some(_) => self,
            Option.None => f(),
        end
    end

    pub fn filter(self, predicate: (T) -> bool) -> Option<T>
        match self
            Option.Some(value) => if predicate(value) then Option.Some(value) else Option.None end,
            Option.None => Option.None,
        end
    end

    pub fn is_some_and(self, predicate: (T) -> bool) -> bool
        match self
            Option.Some(value) => predicate(value),
            Option.None => false,
        end
    end

    pub fn ok_or<E>(self, err: E) -> Result<T, E>
        match self
            Option.Some(value) => Result.Ok(value),
            Option.None => Result.Err(err),
        end
    end

    pub fn ok_or_else<E>(self, err_fn: () -> E) -> Result<T, E>
        match self
            Option.Some(value) => Result.Ok(value),
            Option.None => Result.Err(err_fn()),
        end
    end

    pub fn xor(self, other: Option<T>) -> Option<T>
        match self
            Option.Some(_) => match other
                Option.Some(_) => Option.None,
                Option.None => self,
            end,
            Option.None => other,
        end
    end

    pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)>
        match self
            Option.Some(s) => match other
                Option.Some(o) => Option.Some((s, o)),
                Option.None => Option.None,
            end,
            Option.None => Option.None,
        end
    end

    pub fn zip_with<U, R>(self, other: Option<U>, f: (T, U) -> R) -> Option<R>
        match self
            Option.Some(s) => match other
                Option.Some(o) => Option.Some(f(s, o)),
                Option.None => Option.None,
            end,
            Option.None => Option.None,
        end
    end
end
